import { Template } from "@daml/types";
import Ledger, { CreateEvent, Query } from '@daml/ledger';
/**
 * React hook to get the party currently connected to the ledger.
 */
export declare const useParty: () => string;
/**
 * React Hook that returns the Ledger instance to interact with the connected DAML ledger.
 */
export declare const useLedger: () => Ledger;
/**
 * The result of a query against the ledger.
 *
 * @typeparam T The contract template type of the query.
 * @typeparam K The contract key type of the query.
 * @typeparam I The template id type.
 */
export declare type QueryResult<T extends object, K, I extends string> = {
    /** Contracts matching the query. */
    contracts: readonly CreateEvent<T, K, I>[];
    /** Indicator for whether the query is executing. */
    loading: boolean;
};
/**
 * React Hook for a ``query`` against the ledger.
 *
 * @typeparam T The contract template type of the query.
 * @typeparam K The contract key type of the query.
 * @typeparam I The template id type.
 *
 * @param template The contract template to filter for.
 * @param queryFactory A function returning a query. If the query is omitted, all visible contracts of the given template are returned.
 * @param queryDeps The dependencies of the query (which trigger a reload when changed).
 *
 * @return The result of the query.
 */
export declare function useQuery<T extends object, K, I extends string>(template: Template<T, K, I>, queryFactory: () => Query<T>, queryDeps: readonly unknown[]): QueryResult<T, K, I>;
export declare function useQuery<T extends object, K, I extends string>(template: Template<T, K, I>): QueryResult<T, K, I>;
/**
 * The result of a ``fetch`` against the ledger.
 *
 * @typeparam T The contract template type of the query.
 * @typeparam K The contract key type of the query.
 * @typeparam I The template id type.
 */
export declare type FetchResult<T extends object, K, I extends string> = {
    /** Contracts of the given contract template and key. */
    contract: CreateEvent<T, K, I> | null;
    /** Indicator for whether the fetch is executing. */
    loading: boolean;
};
/**
 * React Hook for a lookup by key against the `/v1/fetch` endpoint of the JSON API.
 *
 * @typeparam T The contract template type of the query.
 * @typeparam K The contract key type of the query.
 * @typeparam I The template id type.
 *
 * @param template The template of the contracts to fetch.
 * @param keyFactory A function returning the contract key of the contracts to fetch.
 * @param keyDeps Dependencies of this hook (for which the fetch is reexecuted on change).
 *
 * @return The fetched contract.
 */
export declare function useFetchByKey<T extends object, K, I extends string>(template: Template<T, K, I>, keyFactory: () => K, keyDeps: readonly unknown[]): FetchResult<T, K, I>;
/**
 * React Hook to query the ledger, the returned result is updated as the ledger state changes.
 *
 * @typeparam T The contract template type of the query.
 * @typeparam K The contract key type of the query.
 * @typeparam I The template id type.
 *
 * @param template The template of the contracts to match.
 * @param queryFactory A function returning a query. If the query is omitted, all visible contracts of the given template are returned.
 * @param queryDeps The dependencies of the query (for which a change triggers an update of the result)
 *
 * @return The matching contracts.
 *
 */
export declare function useStreamQuery<T extends object, K, I extends string>(template: Template<T, K, I>, queryFactory: () => Query<T>, queryDeps: readonly unknown[]): QueryResult<T, K, I>;
export declare function useStreamQuery<T extends object, K, I extends string>(template: Template<T, K, I>): QueryResult<T, K, I>;
/**
 * React Hook to query the ledger. Same as useStreamQuery, but query by contract key instead.
 *
 * @typeparam T The contract template type of the query.
 * @typeparam K The contract key type of the query.
 * @typeparam I The template id type.
 *
 * @param template The template of the contracts to match.
 * @param queryFactory A function returning a contract key.
 * @param queryDeps The dependencies of the query (for which a change triggers an update of the result)
 *
 * @return The matching (unique) contract.
 */
export declare function useStreamFetchByKey<T extends object, K, I extends string>(template: Template<T, K, I>, keyFactory: () => K, keyDeps: readonly unknown[]): FetchResult<T, K, I>;
/**
 * React Hook to reload all active queries.
 */
export declare const useReload: () => () => void;
